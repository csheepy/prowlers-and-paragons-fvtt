/**
 * Extend the base Actor document by defining a custom roll data structure which is ideal for the Simple system.
 * @extends {Actor}
 */
export class ProwlersParagonsActor extends Actor {
  /** @override */
  prepareData() {
    // Prepare data for the actor. Calling the super version of this executes
    // the following, in order: data reset (to clear active effects),
    // prepareBaseData(), prepareEmbeddedDocuments() (including active effects),
    // prepareDerivedData().
    super.prepareData();
  }

  /** @override */
  prepareBaseData() {
    // Data modifications in this step occur before processing embedded
    // documents or derived data.
  }

  /**
   * @override
   * Augment the actor source data with additional dynamic data that isn't 
   * handled by the actor's DataModel. Data calculated in this step should be
   * available both inside and outside of character sheets (such as if an actor
   * is queried and has a roll executed directly from it).
   */
  prepareDerivedData() {
    const actorData = this;

    actorData.derived_power_ranks = {}

    actorData.items.contents.filter(i => i.type === 'power').forEach(power => {
      console.log(power)
      let rr = power.system.rank

      if (power.system.rank_type === 'default') {
        rr = actorData.system.abilities[power.system.connected_ability].value
      }
      if (power.system.rank_type === 'baseline') {
        if (power.system.baseline_scaling_options.half_rank) {
          rr += Math.round((actorData.system.abilities[power.system.connected_ability].value)/2)
        } else if (power.system.baseline_scaling_options.special) {
          rr += power.system.baseline_scaling_options.special_value
        } else {
          rr += actorData.system.abilities[power.system.connected_ability].value
        }
      }

      actorData.derived_power_ranks[power.name] = rr
    });

    const flags = actorData.flags.prowlersandparagons || {};
  }

  /**
   * 
   * @override
   * Augment the actor's default getRollData() method by appending the data object
   * generated by the its DataModel's getRollData(), or null. This polymorphic 
   * approach is useful when you have actors & items that share a parent Document, 
   * but have slightly different data preparation needs.
   */
  getRollData() {
    return { ...super.getRollData(), ...this.system.getRollData?.() ?? null };
  }

  /**
   * Convert the actor document to a plain object.
   * 
   * The built in `toObject()` method will ignore derived data when using Data Models.
   * This additional method will instead use the spread operator to return a simplified
   * version of the data.
   * 
   * @returns {object} Plain object either via deepClone or the spread operator.
   */
  toPlainObject() {
    const result = {...this};

    // Simplify system data.
    result.system = this.system.toPlainObject();

    // Add items.
    result.items = this.items?.size > 0 ? this.items.contents : [];

    // Add effects.
    result.effects = this.effects?.size > 0 ? this.effects.contents : [];

    return result;
  }

  increaseAllAbilities(n) {
    for (const key in this.system.abilities) {
      const newValue = this.system.abilities[key].value + n
      this.update({ [`system.abilities.${key}.value`]: newValue})
    }
  }

  increaseAllTalents(n) {
    for (const key in this.system.talents) {
      const newValue = this.system.talents[key].value + n
      this.update({ [`system.talents.${key}.value`]: newValue})
    }
  }

  async clearPackage() {
    if (this.system.package_applied === 'hero') {
      this.increaseAllAbilities(-3)
      this.increaseAllTalents(-2)
    }
    if (this.system.package_applied === 'superhero') {
      this.increaseAllAbilities(-3)
      this.increaseAllTalents(-3)
    }
    if (this.system.package_applied === 'civilian') {
      this.increaseAllAbilities(-2)
      this.increaseAllTalents(-2)
    }
    return this.update({'system.package_applied': ''})
  }
  async applyPackage(pp) {
    if (this.system.package_applied.length > 0 && pp === 'clear') {
      await this.clearPackage();
      return true;
    }

    await this.clearPackage();
    if (pp === 'hero') {
      this.increaseAllAbilities(3)
      this.increaseAllTalents(2)
      this.update({'system.package_applied': 'hero'})
    }
    if (pp === 'superhero') {
      this.increaseAllAbilities(3)
      this.increaseAllTalents(3)
      this.update({'system.package_applied': 'superhero'})
    }
    if (pp === 'civilian') {
      this.increaseAllAbilities(2)
      this.increaseAllTalents(2)
      this.update({'system.package_applied': 'civilian'})
    }

    return true
  }
}
